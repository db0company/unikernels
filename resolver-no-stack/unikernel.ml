open Lwt.Infix

open Mirage_types_lwt

let src = Logs.Src.create "resolver_no_stack" ~doc:"Resolver no stack"
module Log = (val Logs.src_log src : Logs.LOG)


(*
 *  we want to resolve a name
 *    sender gets a free source port
 *    sender asks for a dns query to be sent
 *    sender calls Lwt_mvar.take on the mvar associated with the source port
 *
 *  a response arrives
 *    listener asks dns resolver to handle the response
 *    listener sees what other work needs to be done:
 *      are there more queries? send a dns query
 *        this means we reserve a new source port and mvar
 *        do we remove the original src_port, mvar (generated by the associated query) from the list in this case?
 *      are there answers?
 *        remove the src_port, mvar from the list
 *        find the mvar associated with this source port and put the answers in the mvar
 *
 *  we end up making a stack of source ports with queries outstanding, and we don't put the result in the mvar at the bottom of the stack, even though that's the one the query is taking from
 *  we know that we're done sending query packets when Dns_resolver.handle_buf doesn't give us any more queries to send.  At that point, we hopefully have at least one answer tuple:
 *   (proto, addr, port, buf) -- the port here is (I think) the port that corresponds to the original request. so if we put the answer into *that* mvar, it might work?
 *
 *)

type t =
  | Original_query of (Cstruct.uint16 * Cstruct.t Lwt_mvar.t)
  | Intermediate_query of Cstruct.uint16

let pp fmt = function
  | Original_query (port, _mvar) -> Format.fprintf fmt "[original query %d]" port
  | Intermediate_query port -> Format.fprintf fmt "[intermediate query %d]" port

let find_original_query src_port = function
  | Original_query (p, _) when p = src_port -> true
  | _ -> false

let remove_intermediate dst_port = List.filter (function
              | Intermediate_query port when dst_port = port ->
                Log.debug (fun f -> f "deleting intermediate port %d" port);
                false
              | _ -> true)

let remove_original dst_port = List.filter (function
              | Original_query (port, _) when dst_port = port ->
                Log.debug (fun f -> f "deleting original port %d" port);
                false
              | _ -> true)

let pp_ports = Fmt.(list ~sep:comma pp)
(* listener, before doing more sends, adds Intermediate_query (free_port ()) to dns_src_ports *)
      (* listener, when it gets replies to some dst_port, removes any Intermediate_query dst_port and then, if there is Original_query (dst_port, mvar) and it has an answer, puts the answer in the mvar *)

module Main (R : RANDOM) (P : PCLOCK) (M : MCLOCK) (TIME : TIME) (N : NETWORK) (DB : Qubes.S.DB) = struct
  module E = Ethernet.Make(N)
  module A = Arp.Make(E)(TIME)
  module I = Qubesdb_ipv4.Make(DB)(R)(M)(E)(A)
  module U = Udp.Make(I)(R)
  module T = Tcp.Flow.Make(I)(TIME)(M)(R)

  let dns_src_ports : t list ref = ref []

  let start _r _pclock mclock _t net db _nc =
    E.connect net >>= fun ethernet ->
    A.connect ethernet >>= fun arp ->
    I.connect db mclock ethernet arp >>= fun ipv4 ->
    U.connect ipv4 >>= fun udp ->
    T.connect ipv4 mclock >>= fun tcp ->

    let now = M.elapsed_ns mclock in
    let server =
      Dns_server.Primary.create ~rng:R.generate Dns_resolver_root.reserved in
    let resolver = ref @@ Dns_resolver.create ~mode:(`Recursive) now R.generate server in

    let just_port = function
      | Original_query (p, _) -> p
      | Intermediate_query p -> p
    in

    let is_dns src_port dst_port =
      List.mem dst_port (List.map just_port !dns_src_ports) && src_port = 53 in

    let rec free_port () =
      let port = Cstruct.BE.get_uint16 (R.generate 2) 0 in
      if List.mem port (List.map just_port !dns_src_ports)
      then free_port ()
      else port
    in

    let send_dns_query src_port (_, dst, buf) =
      U.write ~src_port ~dst ~dst_port:53 udp buf >>= fun _res ->
      Lwt.return_unit
    in

    let handle_dns sender ~src_port ~dst_port buf =
      let p_now = Ptime.v (P.now_d_ps ()) in
      let ts = M.elapsed_ns () in
      let query_or_reply = true in
      let proto = `Udp in
      let post_request_resolver, answers, upstream_queries =
        Dns_resolver.handle_buf !resolver p_now ts query_or_reply proto sender src_port buf in
      resolver := post_request_resolver;
      Log.debug (fun f -> f "handle_dns port list before removing incoming reply: %a" pp_ports !dns_src_ports);
      dns_src_ports := remove_intermediate dst_port !dns_src_ports;
      Log.debug (fun f -> f "dns port list after removing %d (a reply): %a" dst_port Fmt.(list ~sep:comma pp) !dns_src_ports);

      Dns_resolver.stats !resolver;
      Log.info (fun f -> f "sending %d upstream queries" @@ List.length upstream_queries);
      Lwt_list.iter_p (
        let port = free_port () in
        dns_src_ports := (Intermediate_query port) :: !dns_src_ports;
        Log.debug (fun f -> f "added intermediate query port %d to list: %a" port pp_ports !dns_src_ports);
        send_dns_query port
      ) upstream_queries >>= fun () ->
      Log.info (fun f -> f "sitting on %d answers" (List.length answers));

      Lwt_list.iter_p (fun (_proto, addr, port, buf) ->
          Log.debug (fun f -> f "got an answer for port %d" port);
          Log.debug (fun f -> f "current port list: %a" Fmt.(list ~sep:comma pp) !dns_src_ports);
          match List.find_opt (find_original_query port) !dns_src_ports with
          | Some (Original_query (_p, mvar)) -> Lwt_mvar.put mvar buf
          | _ -> Log.err (fun f -> f "nowhere to put our answer :(");
            Lwt.return_unit
        ) answers
    in

    let udp_listener = (fun ~src ~dst:_ ~src_port dst_port buf ->
        if is_dns src_port dst_port
        then handle_dns src ~src_port ~dst_port buf
        else begin
          Log.debug (fun f -> f "non-dns packet received; dropping it");
          Lwt.return_unit end)
    in

    let listeners = (fun ~dst_port -> Some (udp_listener dst_port)) in

    let udp_arg : U.ipinput = U.input ~listeners udp in

    (* ask resolver about a name, send a request, we get the reply, but we have control over the network *)
    (* at least one other service runs on it - another listener, not network but udp service *)
    (* you=firewall can't take all packets and send them to dns *)

    Lwt.async (fun () ->
    N.listen net ~header_size:Ethernet_wire.sizeof_ethernet
                  (E.input ~arpv4:(A.input arp)
                     ~ipv4:(I.input
                              ~udp:udp_arg
                              ~tcp:(fun ~src:_ ~dst:_ _contents -> Lwt.return_unit)
                              ~default:(fun ~proto:_ ~src:_ ~dst:_ _ ->
                                  (* TODO: handle ICMP destination unreachable messages here,
                                              possibly with some detailed help text? *)
                                  Lwt.return_unit)
                              ipv4
                           )
                     ~ipv6:(fun _ -> Lwt.return_unit)
                     ethernet
                  ) >>= fun _ -> Lwt.return_unit

    );

    let query_cstruct, _ = Dns_client.make_query `Udp (Domain_name.of_string_exn "robur.io") Dns.Rr_map.A in

    let send_test_queries src_port =
      let p_now = Ptime.v (P.now_d_ps ()) in
      let ts = M.elapsed_ns () in
      let query_or_reply = true in
      let proto = `Udp in
      let sender = List.hd @@ I.get_ip ipv4 in
      dns_src_ports := (Original_query (src_port, Lwt_mvar.create_empty ()) :: !dns_src_ports);
      let new_resolver, answers, upstream_queries = Dns_resolver.handle_buf !resolver p_now ts query_or_reply proto sender src_port query_cstruct in
      resolver := new_resolver;
      Dns_resolver.stats !resolver;
      Log.info (fun f -> f "sending %d further queries" (List.length upstream_queries));
      Lwt_list.iter_p (send_dns_query src_port) upstream_queries >>= fun () ->
      Log.info (fun f -> f "%d answers known before sending any queries" (List.length answers));
      Lwt.return_unit
    in

    let rec try_queries ~retries =
      if retries <= 0 then Lwt.return_unit
      else begin
        let src_port = free_port () in
        send_test_queries src_port >>= fun () ->
        match List.find_opt (find_original_query src_port) !dns_src_ports with
        | Some (Original_query (_p, mvar)) ->
          Log.info (fun f -> f "About to take answers");
          Lwt_mvar.take mvar >>= fun buf ->
          dns_src_ports := remove_original src_port !dns_src_ports;
          let () = match Dns.Packet.decode buf with
          | Ok p -> Log.debug (fun f -> f "got a reply packet, yay! %a" Dns.Packet.pp p)
          | Error e -> Log.debug (fun f -> f "got a packet dns couldn't parse: %a" Dns.Packet.pp_err e)
          in
          Dns_resolver.stats !resolver;
          Lwt.return_unit
        | _ -> Log.err (fun f -> f "couldn't find my src port %d in the list - can't wait for reply :(" src_port);
          Log.debug (fun f -> f "current port list: %a" Fmt.(list ~sep:comma pp) !dns_src_ports);
          Lwt.return_unit
      end
    in
    try_queries ~retries:2 >>= fun () ->
    Log.info (fun f -> f "all done. Resolver status: ");
    Dns_resolver.stats !resolver;
    Log.debug (fun f -> f "current port list: %a" Fmt.(list ~sep:comma pp) !dns_src_ports);
    Lwt.return_unit

end
